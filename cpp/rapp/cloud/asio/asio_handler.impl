namespace rapp {
namespace cloud {
///
/// asio_handler template implementation
///
template <class T> 
asio_handler<T>::asio_handler(
                               const std::function<void(std::string)> cloud_function,
                               const std::function<void(boost::system::error_code)> error_function,
                               const std::function<void(boost::system::error_code)> shutdown_function
							 )
: 
  http_response(error_function), 
  cloud_cb_(cloud_function), 
  error_cb_(error_function),
  close_cb_(shutdown_function)
{
    assert(cloud_cb_ && error_cb_);
}

template <class T>
void asio_handler<T>::set_socket(const std::shared_ptr<T> socket)
{
    assert(socket);
    socket_ = socket;
}

template <class T> 
void asio_handler<T>::write_request(const boost::system::error_code & err,
                                    const std::size_t bytes)
{       
    //if (!err) {
        // read until first newline
        boost::asio::async_read_until(*socket_,
                                      buffer_,
                                      "\r\n",
                                      boost::bind(&asio_handler::read_status_line, 
                                                  this, 
                                                  boost::asio::placeholders::error,
                                                  boost::asio::placeholders::bytes_transferred));
    //}
    //else {
        // request error/wrong request, header or post
        //end(err);       
	//}
}

template <class T>
void asio_handler<T>::read_status_line(const boost::system::error_code & err,
                                       const std::size_t bytes)
{
    if (!err) {
       if (http_response::check_http_header()) {
        // read entire header (double newlines denote end of HTTP header) - callback `read_headers`
        boost::asio::async_read_until(*socket_,
                                      buffer_, 
                                      "\r\n\r\n",
                                      boost::bind(&asio_handler::read_headers, 
                                                  this, 
                                                  boost::asio::placeholders::error,
                                                  boost::asio::placeholders::bytes_transferred));
        }
    }
    else {
        end(err);
	}
}

template <class T>
void asio_handler<T>::read_headers(const boost::system::error_code & err,
                                   const std::size_t bytes)
{
    if (!err) {
        // strip HTTP Header, calculate actual POST bytes received,
        // and if needed ask for more POST data.
        unsigned int remaining = http_response::strip_http_header(bytes);
        if (remaining > 0) {
            boost::asio::async_read(*socket_.get(),
                                    buffer_,
                                    boost::asio::transfer_at_least(remaining),
                                    boost::bind(&asio_handler::read_content, 
                                                this, 
                                                boost::asio::placeholders::error, 
                                                boost::asio::placeholders::bytes_transferred));
        }
        // we may have received all the data at once
        // in which case simply close and quit 
        // we add zero bytes, since we called `strip_http_header`
        else {
            http_response::consume_buffer(cloud_cb_, bytes);
            close_cb_(boost::system::errc::make_error_code(
                                           boost::system::errc::success));
        }
    }
    else {
        end(err);
	}
}

template <class T>
void asio_handler<T>::read_content(
                                    const boost::system::error_code & err,
                                    const std::size_t bytes
                                  )
{
    if (!err) {
        // received all data 
        if (http_response::consume_buffer(cloud_cb_, bytes)) {
            close_cb_(boost::system::errc::make_error_code(
                                           boost::system::errc::success));
        }
        // still data left to receive
        else {
            unsigned int left = http_response::content_length() - http_response::bytes_received();
            boost::asio::async_read(*socket_.get(),
                                    http_response::buffer_,
                                    boost::asio::transfer_at_least(left),
                                    boost::bind(&asio_handler::read_content, 
                                                this, 
                                                boost::asio::placeholders::error, 
                                                boost::asio::placeholders::bytes_transferred));
        }
    }
    // error - normally EOF, meaning the server closed the connection
    else {
        end(err);
	}
}

template <class T>
void asio_handler<T>::end(const boost::system::error_code & err)
{
    if (err) {
        error_cb_(err);
    }
    http_response::end();
    close_cb_(err);
}

}
}
